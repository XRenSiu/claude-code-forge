# Subagent vs Skill 核心区别

> 一份快速决策指南，帮助你选择正确的封装方式

---

## 一、一句话总结

| 类型 | 本质 | 比喻 |
|------|------|------|
| **Subagent** | 独立的 AI 实例，全新上下文 | 请来的**外部专家** |
| **Skill** | 注入当前上下文的知识 | 学会的**内化方法** |

---

## 二、可视化对比

### Subagent 工作方式

```
┌─────────────────────────────────────┐
│           Main Agent                │
│  (有完整的对话历史和项目上下文)       │
│                                     │
│    dispatch("code-reviewer", {      │
│      CODE_PATH: "src/",             │
│      PLAN_DOC: "docs/plan.md"       │
│    })                               │
│         │                           │
│         ▼                           │
│  ┌─────────────────────────────┐    │
│  │     Subagent (新上下文)      │    │
│  │                             │    │
│  │  ❌ 不知道对话历史           │    │
│  │  ❌ 不知道之前的讨论         │    │
│  │  ✅ 只看到传入的参数         │    │
│  │  ✅ 独立执行，返回结果       │    │
│  └─────────────────────────────┘    │
│         │                           │
│         ▼                           │
│    收到结构化结果                    │
└─────────────────────────────────────┘
```

### Skill 工作方式

```
┌─────────────────────────────────────┐
│           Main Agent                │
│  (有完整的对话历史和项目上下文)       │
│                                     │
│    invoke("test-driven-dev")        │
│         │                           │
│         ▼                           │
│  ┌─────────────────────────────┐    │
│  │   Skill 内容被注入上下文      │    │
│  │                             │    │
│  │  ✅ 保留所有对话历史         │    │
│  │  ✅ 知道之前的讨论           │    │
│  │  ✅ 主 Agent 继续执行        │    │
│  │  ✅ 融入当前工作流           │    │
│  └─────────────────────────────┘    │
│         │                           │
│         ▼                           │
│    主 Agent 按 Skill 指引继续工作   │
└─────────────────────────────────────┘
```

---

## 三、关键区别对照表

| 维度 | Subagent | Skill |
|------|----------|-------|
| **上下文** | 🆕 全新，完全隔离 | 📎 注入当前上下文 |
| **历史记忆** | ❌ 不知道之前发生了什么 | ✅ 知道所有对话历史 |
| **执行者** | 独立的 AI 实例 | 主 Agent 本身 |
| **返回形式** | 结构化结果 | 无返回，直接影响后续行为 |
| **心智模型** | "另一个人" | "学到的知识" |
| **适合任务** | 需要客观视角的独立任务 | 需要上下文的持续性工作 |
| **调用开销** | 较高（新实例） | 较低（上下文注入） |
| **Token 消耗** | 每次独立消耗 | 一次注入，持续使用 |

---

## 四、快速决策流程图

```
                    ┌─────────────────────────────┐
                    │     我需要完成一个任务       │
                    └─────────────┬───────────────┘
                                  │
                                  ▼
                    ┌─────────────────────────────┐
                    │  这个任务需要"第三方视角"吗？ │
                    │  (客观评估、独立判断、审查)   │
                    └─────────────┬───────────────┘
                                  │
                    ┌─────────────┴─────────────┐
                    │                           │
                    ▼                           ▼
                   是                          否
                    │                           │
                    ▼                           ▼
        ┌───────────────────┐     ┌───────────────────────────┐
        │  任务有清晰的      │     │  任务需要了解当前项目      │
        │  输入/输出边界吗？  │     │  上下文和对话历史吗？      │
        └─────────┬─────────┘     └─────────────┬─────────────┘
                  │                             │
        ┌─────────┴─────────┐         ┌─────────┴─────────┐
        │                   │         │                   │
        ▼                   ▼         ▼                   ▼
       是                  否        是                  否
        │                   │         │                   │
        ▼                   ▼         ▼                   ▼
   ┌─────────┐        ┌─────────┐ ┌─────────┐      ┌─────────────┐
   │Subagent │        │  Skill  │ │  Skill  │      │ 可能不需要   │
   │  ✅     │        │  考虑   │ │   ✅    │      │ 特殊封装     │
   └─────────┘        └─────────┘ └─────────┘      └─────────────┘
```

---

## 五、快速决策清单

当你不确定时，问自己这些问题：

| # | 问题 | 是 → | 否 → |
|---|------|------|------|
| 1 | 需要"不知道实现过程"的客观视角吗？ | **Subagent** | ↓ |
| 2 | 任务有清晰的输入/输出边界吗？ | **Subagent** | ↓ |
| 3 | 希望模拟"另一个人"来做这件事吗？ | **Subagent** | ↓ |
| 4 | 需要了解当前对话的完整历史吗？ | **Skill** | ↓ |
| 5 | 是一个持续性的工作方式/规范吗？ | **Skill** | ↓ |
| 6 | 需要在工作过程中反复参考吗？ | **Skill** | ↓ |
| 7 | 以上都不是 | 可能不需要封装 | - |

---

## 六、典型场景对照

### Subagent 典型场景

| 场景 | 为什么是 Subagent |
|------|-------------------|
| **Code Review** | 审查者不应知道实现者的"心路历程"，需要客观评估 |
| **Security Audit** | 需要"攻击者视角"，与开发者视角隔离 |
| **Test Generation** | 测试应基于规格而非实现，避免"验证实现"的测试 |
| **Documentation** | 文档写给"不知道代码的人"看，需模拟读者视角 |
| **Spec Compliance** | 严格对照规格，不接受"差不多就行" |
| **Performance Analysis** | 需要客观度量，不受主观影响 |

### Skill 典型场景

| 场景 | 为什么是 Skill |
|------|----------------|
| **Brainstorming** | 需要了解用户完整需求描述，是渐进式对话过程 |
| **Writing Plans** | 需要基于之前讨论的结论，了解项目约束 |
| **TDD** | 是工作方式，需要在写代码时持续应用 |
| **Systematic Debugging** | 需要记住已尝试的方案，是迭代过程 |
| **Git Workflow** | 需要知道当前分支、改动，是持续参考的规范 |
| **Coding Standards** | 在写每一行代码时参考，是内化的知识 |

---

## 七、边界案例分析

### 案例 1：Requesting Code Review

**问题**：教主 Agent "如何请求代码审查"是 Skill 还是 Subagent？

**答案**：这是一个 **Skill**，但它会调用一个 **Subagent**。

```
skills/requesting-code-review/SKILL.md  ← Skill（流程知识）
  └── 告诉主 Agent 何时、如何 dispatch code-reviewer

agents/code-reviewer.md  ← Subagent（独立执行）
  └── 实际执行审查的独立代理
```

**设计模式**：**Skill 定义流程，Subagent 执行独立任务**

### 案例 2：代码生成

**问题**：让 AI 生成代码是 Skill 还是 Subagent？

**答案**：取决于场景。

| 场景 | 选择 | 原因 |
|------|------|------|
| 按计划实现功能 | **Skill** | 需要知道项目上下文、之前的讨论 |
| 生成独立的工具函数 | **Subagent** | 可以独立完成，不需要太多上下文 |
| 按 Spec 生成 API 代码 | **Subagent** | 只需要 Spec，不需要对话历史 |

### 案例 3：代码解释

**问题**：解释一段代码是 Skill 还是 Subagent？

**答案**：通常**不需要封装**，或用 **Skill**。

- 解释代码需要知道用户的提问意图
- 需要根据用户的技术水平调整解释深度
- 是一个对话性任务，不是独立任务

### 案例 4：性能分析

**问题**：分析代码性能是 Skill 还是 Subagent？

**答案**：**Subagent**。

- 性能分析需要客观的度量
- 有清晰的输入（代码）和输出（性能报告）
- 需要系统性检查，而非随意评估

---

## 八、组合使用模式

### 模式 1：Skill 调度 Subagent

```
┌─────────────────────────────────────────────┐
│  Skill: subagent-driven-development         │
│  (定义工作流程)                              │
│                                             │
│  1. 读取 Plan                               │
│  2. 对每个任务:                              │
│     └─ dispatch Implementer Subagent        │
│     └─ dispatch Spec Checker Subagent       │
│     └─ dispatch Code Reviewer Subagent      │
│  3. 汇总结果                                │
└─────────────────────────────────────────────┘
```

### 模式 2：Subagent 返回触发 Skill

```
┌─────────────────────────────────────────────┐
│  Code Reviewer Subagent 返回:               │
│  "发现安全漏洞，建议使用 systematic-debugging" │
│                                             │
│  主 Agent 自动 invoke:                      │
│  └─ Skill: systematic-debugging             │
│  └─ 按 Skill 指引修复问题                    │
└─────────────────────────────────────────────┘
```

### 模式 3：并行 Subagent

```
┌─────────────────────────────────────────────┐
│  主 Agent 同时 dispatch:                    │
│                                             │
│  ┌─────────────┐  ┌─────────────┐           │
│  │ Code Review │  │ Security    │           │
│  │ Subagent    │  │ Subagent    │           │
│  └──────┬──────┘  └──────┬──────┘           │
│         │                │                  │
│         └────────┬───────┘                  │
│                  ▼                          │
│         汇总两份报告                         │
└─────────────────────────────────────────────┘
```

---

## 九、为什么区分很重要？

### 错误选择的后果

| 场景 | 错误选择 | 后果 |
|------|----------|------|
| Code Review 用 Skill | Skill | 审查者知道实现过程，可能"自己给自己放水" |
| TDD 用 Subagent | Subagent | 每次都是新上下文，不记得之前测试了什么 |
| Brainstorming 用 Subagent | Subagent | 不知道用户之前说了什么，需要反复传递信息 |
| Debug 用 Subagent | Subagent | 不记得已经尝试过的方案，重复无效尝试 |

### 正确选择的收益

| 场景 | 正确选择 | 收益 |
|------|----------|------|
| Code Review 用 Subagent | Subagent | 客观独立的审查，发现实现者遗漏的问题 |
| TDD 用 Skill | Skill | 持续遵循 TDD 纪律，记住测试状态 |
| Brainstorming 用 Skill | Skill | 理解完整上下文，渐进式澄清需求 |
| Debug 用 Skill | Skill | 记住尝试历史，系统性排除问题 |

---

## 十、总结图

```
┌─────────────────────────────────────────────────────────────┐
│                                                             │
│   Subagent = 独立专家                                        │
│   "我请一个人来帮我审查/分析/生成，他只看我给他的材料"          │
│                                                             │
│   ✓ Code Review          ✓ Security Audit                  │
│   ✓ Test Generation      ✓ Doc Writing                     │
│   ✓ Spec Compliance      ✓ Performance Analysis            │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Skill = 内化方法                                           │
│   "我学会了一套方法，在工作中持续应用"                          │
│                                                             │
│   ✓ Brainstorming        ✓ Writing Plans                   │
│   ✓ TDD                  ✓ Debugging                       │
│   ✓ Git Workflow         ✓ Coding Standards                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 十一、核心原则速记

**三句话记住区别**：

1. **Subagent** = 需要"新鲜眼睛"和"客观视角" → **独立专家**
2. **Skill** = 需要"上下文"和"持续参考" → **内化方法**
3. **最佳实践** = Skill 定义流程，在需要时调度 Subagent

**决策口诀**：

> 审查分析要隔离 → Subagent
> 方法流程要内化 → Skill
> 不确定就问一句："这需要另一个人来做吗？"

---

## 十二、补充：Rules 的位置

Rules 是第三种封装方式，与 Skill 容易混淆：

| 维度 | Subagent | Skill | Rules |
|------|----------|-------|-------|
| **本质** | 独立 AI 实例 | 注入的方法 | 参考文档 |
| **上下文** | 🆕 全新隔离 | 📎 注入当前 | 📖 按需读取 |
| **心智模型** | "另一个人" | "学到的方法" | "参考手册" |
| **内容类型** | 完整角色定义 | 工作流程/步骤 | 约束/规范 |
| **适合场景** | 需要客观视角 | 持续遵循的方法 | 遵守的规范 |
| **示例** | code-reviewer | test-driven-dev | api-patterns |

**Skill vs Rules 快速判断**：
- 是"如何做"的方法 → **Skill**
- 是"做什么/不能做什么"的约束 → **Rules**
