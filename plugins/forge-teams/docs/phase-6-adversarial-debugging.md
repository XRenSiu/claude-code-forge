# 阶段 6：对抗调试 (Adversarial Debugging)

> 通过竞争假设 + 对抗辩论定位问题根因，用 TDD 修复

---

## 📋 阶段概述

| 维度 | 说明 |
|------|------|
| **目标** | 通过竞争假设 + 对抗辩论定位问题根因，用 TDD 修复 |
| **输入** | Phase 5 审查报告中的问题 |
| **输出** | 根因分析报告 + TDD 修复 |
| **上游阶段** | 对抗审查（阶段5） |
| **下游阶段** | 返回阶段5 重新审查 |

---

## 🧩 组件清单

| 类型 | 名称 | 模型 | 说明 |
|------|------|------|------|
| **Agent** | `hypothesis-investigator` (x3-5) | sonnet | 假设调查员，每人负责一个独立假设 |
| **Agent** | `devils-advocate` (x1) | opus | 魔鬼辩护人，专职挑战所有假设 |
| **Agent** | `evidence-synthesizer` (x1) | opus | 证据综合员，中立仲裁 + 评分裁决 |
| **Skill** | `adversarial-debugging` | — | Phase 6 编排（5-Phase Protocol） |
| **Rule** | `adversarial-protocol.md` | — | 对抗辩论通信规则 |

---

## 💡 为什么这样设计

### 单 Agent 调试的问题

pdforge 的 `systematic-debugging` 是一个扎实的 4+1 阶段框架（问题收集 → 根因调查 → 模式分析 → 假设测试 → TDD 修复），但它仍然是单 agent 工作：

| 问题 | 表现 | 后果 |
|------|------|------|
| **锚定效应** (Anchoring) | 找到第一个看似合理的原因就停止 | 修了症状不治根因 |
| **隧道视野** (Tunnel Vision) | 深入调查一个假设，忽略其他方向 | 真正根因在另一个维度 |
| **无挑战者** (No Challenger) | 没有人质疑推理过程中的逻辑漏洞 | 弱证据当结论使用 |
| **确认偏误** (Confirmation Bias) | 找到支持假设的证据就"确认"了 | 忽视矛盾证据 |

**现实世界类比**：

```
单 agent 调试 ≈ 一个侦探独自破案
                 ↓
    找到一条线索 → 沿着这条线走到底
    可能对了，也可能追了一条死胡同

对抗调试    ≈ 多个侦探各自追踪不同线索，然后在法庭辩论
                 ↓
    三条线索并行调查 → 最强证据在辩论中胜出
    真凶是经受住交叉质询的那个
```

---

### 为什么竞争假设 (Competing Hypotheses)

多个调查员，每人被**分配一个独立假设**去调查：

| 设计目标 | 机制 | 效果 |
|---------|------|------|
| 防止锚定 | 每个调查员"绑定"到自己的假设 | 不会过早放弃，深入调查 |
| 防止隧道视野 | 不同假设探索不同代码路径 | 多方向并行覆盖 |
| 创造竞争 | 多假设争夺"最佳解释"地位 | 最强证据自然胜出 |

**示例**：Bug 导致间歇性测试失败

```
调查员 A: "竞态条件 (Race Condition)"
          → 追踪 async handler 的时序问题
          → 发现某些测试中事件顺序不确定

调查员 B: "状态污染 (State Pollution)"
          → 追踪测试间共享状态
          → 发现全局变量在 beforeEach 中未重置

调查员 C: "内存泄漏导致 GC 暂停"
          → 追踪内存使用模式
          → 发现事件监听器未正确清理

每个调查员找到不同的证据
  → 辩论揭示哪个假设能解释所有症状
  → 最终发现：状态污染是根因（解释了所有已知症状）
```

---

### 为什么 Devil's Advocate 用 opus

Devil's Advocate 需要完成的任务超出了一般代码搜索的复杂度：

| 能力需求 | 为什么 sonnet 不够 | opus 的优势 |
|---------|------------------|-----------|
| 逻辑缺陷检测 | 需要深层推理链分析 | 更强的抽象推理 |
| 确认偏误识别 | 需要理解认知心理学模式 | 更好的元认知能力 |
| 替代解释生成 | 需要创造性地重新解释同一证据 | 更强的发散思维 |
| 挑战深度校准 | 太浅无用，太深浪费 | 更好的判断力和分寸感 |

**核心差异**：调查员做的是"搜索 + 分析"（sonnet 强项），挑战者做的是"评判 + 推理"（opus 强项）。

---

### 为什么 Evidence Synthesizer 而非 Lead 判定

| 选项 | 优点 | 缺点 |
|------|------|------|
| Lead 直接判定 | 少一个 agent session | Lead 已有上下文偏见，判断不够中立 |
| 独立 Synthesizer | 中立、使用正式评分矩阵 | 多一个 agent session |

**选择 Evidence Synthesizer 的原因**：

1. **Lead 上下文偏见**：Lead 从 Phase 1 协调整个流水线，可能对某些代码区域有先入之见
2. **正式评分矩阵**：Synthesizer 维护 Evidence Board + 5 维加权评分，比 Lead 的直觉判断更可审计
3. **与 P2 设计一致**：P2 也使用独立 Arbiter（而非 Lead）做架构裁决，保持模式一致性

**评分矩阵权重**：

```
┌─────────────────────────────────────────────────────────────┐
│  Evidence Strength (证据强度)            30%  ████████████  │
│  Challenge Survival (挑战存活)           25%  ██████████    │
│  Explanation Completeness (解释完整性)   20%  ████████      │
│  Parsimony (简洁性/奥卡姆剃刀)          15%  ██████        │
│  Verifiability (可验证性)               10%  ████          │
└─────────────────────────────────────────────────────────────┘
                                         100%
```

---

### 收敛纪律 (Convergence Discipline)

辩论必须有限收敛，否则成本和时间不可控。

```
辩论价值曲线：

价值 ▲
     │    ┌──────────────────────── ~90% 价值在前 2 轮
     │   /│
     │  / │
     │ /  │  ← 第 3 轮后边际收益急剧递减
     │/   │
     ├────┼──────────────────────► 轮次
     1    2    3    4    5
```

| 收敛类型 | 条件 | 动作 |
|---------|------|------|
| **强收敛** | 假设 >= 8/10 + 所有挑战已回应 | 立即进入 Phase 4（Verdict & Fix） |
| **弱收敛** | 领先假设领先 >= 3 分 | 再一轮确认后进入 Phase 4 |
| **未收敛** | 多个假设分数相近（差距 < 2 分） | 继续辩论或设计区分测试 |
| **强制收敛** | 已达 3 轮辩论 | 选择最强假设，标注不确定性 |

**为什么 3 轮上限？**

调试研究表明：大部分有用证据在前 1-2 轮浮出。第 3 轮用于边缘情况。超过 3 轮，辩论趋于循环——参与者开始重复论点或纠缠细枝末节，产生噪音而非信号。

---

### 关键设计决策

| 决策 | 选项 A | 选项 B | 选择 | 原因 |
|------|--------|--------|------|------|
| 假设数量 | 2 个 | 3-5 个 | 3 个（典型） | 覆盖主要方向，不过度发散 |
| Devil's Advocate | 无 | 有 | 有 | 防止弱证据通过，确保假设质量 |
| 评分方式 | 主观判断 | 5 维加权矩阵 | 5 维加权矩阵 | 可审计、可追溯的决策 |
| 修复方式 | 直接修复 | TDD 修复 | TDD | 确保不引入回归，修复可验证 |
| 修复后流程 | 结束 | 回到 P5 重审 | 回到 P5 | 形成闭环，验证修复效果 |
| DA 模型 | sonnet | opus | opus | 挑战需要更强分析推理能力 |
| Synthesizer 模型 | sonnet | opus | opus | 仲裁需要综合大量信息做判定 |

---

## 🔧 组件详解

### hypothesis-investigator Agent (x3-5 实例)

```yaml
name: hypothesis-investigator
model: sonnet
tools: Read, Grep, Glob, Bash
```

**4 步调查协议**：

```
Step 1: 理解假设
├── 明确假设、可证伪预测、否定条件
└── 确定调查起点

Step 2: 收集证据
├── 代码考古 (git log, git blame)
├── 调用链追踪 (函数调用图)
├── 数据流分析 (变量赋值 + 转换)
└── Git Bisect (二分定位引入点)

Step 3: 构建证据报告
├── Supporting Evidence (支持证据 + 强度)
├── Counter Evidence (不利证据 + 影响)
├── Confidence Score (置信度 1-10)
└── Open Questions (待解问题)

Step 4: 回应挑战
├── 不做防御性回应，认真考虑挑战合理性
├── 用具体代码证据回应，不用直觉或推测
├── 承认有效挑战，调整置信度
└── 补充调查盲区
```

**核心约束**（Rule 4: Honest Reporting）：

```
╔══════════════════════════════════════════════════════════════╗
║  调查员必须报告不利证据（Counter Evidence）。                  ║
║  隐瞒不利证据 → 假设被标记为不可信。                          ║
║  科学精神：否定假设的证据和支持它的一样有价值。               ║
╚══════════════════════════════════════════════════════════════╝
```

---

### devils-advocate Agent (x1)

```yaml
name: devils-advocate
model: opus
tools: Read, Grep, Glob, Bash
```

**4 部分挑战方法论**：

| 方法 | 目的 | 操作 |
|------|------|------|
| 证据质量评估 | 检查证据的可复现性、相关性、完整性 | 尝试独立复现 + 检查上下文 |
| 逻辑缺陷检测 | 寻找推理链中的谬误 | 6 种逻辑谬误检查清单 |
| 反证收集 | 主动搜索否定假设的证据 | 代码搜索 + git 历史分析 |
| 替代解释生成 | 对同一证据提出不同解释 | 提出至少一个替代假设 |

**6 种逻辑谬误检测**：

| 谬误 | 在调试中的表现 | DA 检测方法 |
|------|--------------|-----------|
| 循环论证 | "是 bug 因为有 bug" | 检查推理链是否自我引用 |
| 因果混淆 | "A 和 B 同时出现 → A 导致了 B" | 寻找第三因素 C |
| 幸存者偏差 | "出问题时有这个模式" | 检查正常时是否也有这个模式 |
| 锚定效应 | 过度依赖最初的发现 | 检查后续调查是否受第一发现影响 |
| 确认偏误 | 只找支持的证据 | 检查是否遗漏反面数据 |
| 以偏概全 | "这个文件有 bug → 这类文件都有" | 检查结论是否过度泛化 |

**挑战强度随置信度调整**：

```
调查员置信度       DA 挑战强度
8-10 (高度自信) → 最高：必须找到决定性反证
5-7  (中等自信) → 高  ：推动收集更多证据
3-4  (低自信)   → 中  ：检查是否值得继续
1-2  (极低自信) → 低  ：建议淘汰假设
```

---

### evidence-synthesizer Agent (x1)

```yaml
name: evidence-synthesizer
model: opus
tools: Read, Grep, Glob, Bash
```

**核心产出**：

1. **Evidence Board** — 实时更新的证据看板

```
┌─────────────────────────────────────────────────────────────┐
│  EVIDENCE BOARD                       Round: 2 / 3          │
├──────────┬────────┬──────────┬────────┬────────────────────┤
│ Hypothesis│ Score  │ Evidence │Counter │ Status             │
│          │        │ For      │Evidence│                    │
├──────────┼────────┼──────────┼────────┼────────────────────┤
│ H1: Race │ 7.45   │ 3 items  │ 1 item │ ACTIVE             │
│ H2: State│ 5.20   │ 2 items  │ 2 items│ WEAKENED           │
│ H3: Leak │ 2.10   │ 1 item   │ 3 items│ ELIMINATED (R1)    │
└──────────┴────────┴──────────┴────────┴────────────────────┘
```

2. **状态转换**：

```
ACTIVE ──────────────────────────────────── (默认起始状态)
  │
  ├── WEAKENED ──────────────────────────── (有效挑战未完全回应)
  │       │
  │       ├── ACTIVE ────────────────────── (新强证据恢复)
  │       │
  │       └── ELIMINATED ───────────────── (持续无法回应)
  │
  └── ELIMINATED ────────────────────────── (决定性反证)
```

3. **Verdict 报告**：根因判定 + 评分分解 + 置信度 + 推荐修复方向

---

## 🚀 使用流程

### 在流水线中使用

```
Phase 5: Adversarial Review
    │
    │── REQUEST CHANGES (发现 bug)
    │
    ▼
Phase 6: Adversarial Debugging (本阶段)
    │
    ├── Phase 0: INTAKE (收集问题信息)
    ├── Phase 1: HYPOTHESIZE (生成 3-5 假设)
    ├── Phase 2: TEAM ASSEMBLY (创建团队)
    ├── Phase 3: DEBATE (2-3 轮对抗辩论)
    └── Phase 4: VERDICT & FIX (判定 + TDD 修复)
         │
         ▼
    回到 Phase 5 (限定范围重审)
```

### 命令示例

```bash
# 流水线中由 P5 的 REQUEST CHANGES 自动触发
/forge-teams --phase 6

# 单独使用对抗调试 skill
/adversarial-debugging

# 针对特定 bug
/adversarial-debugging "间歇性测试超时，每 10 次大约失败 2 次"
```

---

## ⚙️ vs pdforge 对比

| 维度 | pdforge (systematic-debugging) | forge-teams (P6) | 价值 |
|------|-------------------------------|------------------|------|
| 架构 | 单 agent 4+1 阶段 | 多 agent 5-Phase Protocol | 多视角，不遗漏 |
| 假设 | 单 agent 逐个验证 | 多 agent 并行竞争 | 每个假设获得充分调查 |
| 挑战 | 无（Agent 自我评估） | Devil's Advocate 专职挑战 | 防止弱证据通过 |
| 判定 | Agent 自己判定 | Evidence Synthesizer 评分裁决 | 更客观的根因判定 |
| 评分 | 无正式评分 | 5 维加权矩阵 | 可审计、可追溯 |
| 修复 | TDD | TDD + 回到 P5 重审 | 闭环验证修复效果 |
| 首次正确率 | ~40% | ~80%+ | 大幅减少调试迭代 |
| Token | 1x | ~10x | 复杂 bug 值得投资 |
| 速度 | 中等（顺序） | 快（并行调查） | 调查阶段并行加速 |

### 选型指南

```
遇到 Bug →
    ├── 原因明显 → 直接修复
    ├── 单 agent 可定位 → systematic-debugging (pdforge)
    ├── 单 agent 难定位 → adversarial-debugging (forge-teams)
    ├── 间歇性故障 → adversarial-debugging (forge-teams)
    └── systematic-debugging 失败 → adversarial-debugging (forge-teams)
```

---

## ⚠️ 注意事项

### 必须遵守

1. **独立调查**：调查员之间在辩论开始前不交流——每人只知道自己的假设，不知道其他人在查什么
2. **不利证据必须报告**：调查员隐瞒反证 → 假设被标记为不可信，可能被直接淘汰
3. **收敛纪律**：3 轮后强制判定，不允许无限辩论——边际价值在第 3 轮后急剧递减
4. **TDD 修复**：修复必须先写复现 bug 的测试（RED → GREEN → 全量回归）
5. **闭环验证**：修复后必须回到 P5 重新审查，限定范围（只审修复涉及的代码）

### 反模式列表

| 反模式 | 症状 | 正确做法 |
|--------|------|---------|
| 假设不可证伪 | "可能是某种未知问题" | 每个假设必须有明确的否定条件 |
| 假设不独立 | H2 依赖于 H1 成立 | 假设之间正交或互斥 |
| Lead 自己调查 | Lead 开始 grep 代码 | Lead 只协调，用 delegate mode |
| 跳过辩论 | "我已经知道答案了" | 至少 2 轮辩论，最强假设也需要考验 |
| 辩论超过 3 轮 | 调查员开始重复论点 | 3 轮后强制进入 Verdict |
| 不清理 Team | 调试完成后 agent 还在运行 | shutdown + TeamDelete |
| 忽视评分矩阵 | Lead 凭直觉判定根因 | 使用 Synthesizer 的 5 维评分做决策 |
| 修复前不写测试 | "先修了再说" | TDD：先写失败测试 → 最小修复 → GREEN |
| DA 无理取闹 | 没有证据的空口质疑 | 每个挑战必须有具体理由和预期回应 |

### 常见借口及反驳

| 借口 | 反驳 |
|------|------|
| "我知道 bug 在哪" | 单 agent 首次假设正确率只有 40% |
| "太贵了" | 3 小时随机修复 vs 30 分钟精准定位 |
| "这个 bug 很简单" | "简单"的 bug 最容易产生锚定效应 |
| "没时间组建团队" | Team 创建只需几秒，调查并行节省总时间 |
| "systematic-debugging 就够了" | 如果够了你就不会需要看这个文档 |

---

## 🔗 下一阶段

修复完成后，返回 **阶段 5：对抗审查** 进行范围限定重审：

```
Phase 6 Fix 完成
    ↓
git commit -m "fix: [根因描述]"
    ↓
Phase 5 Re-review (范围: 只审修复涉及的文件)
    ├── APPROVE → Phase 7 (交叉验收 + 部署)
    └── REQUEST CHANGES → 回到 Phase 6
```
