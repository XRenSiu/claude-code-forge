# 设计哲学 (Design Philosophy)

> forge-teams 的核心理念：用结构化对抗消除单 Agent 认知偏差，用多 Agent 协作提升工程质量

---

## 📋 概述

forge-teams 不是把 pdforge 的流程"多跑几遍"。它是一种根本不同的质量保障方法论：**让多个独立思考的 Agent 互相挑战**，而不是让一个 Agent 自己检查自己。

本文档解释了这个设计选择背后的认知科学依据、架构权衡、以及每个关键设计决策的推理过程。

---

## 🧩 为什么需要对抗协作 (Why Adversarial Collaboration)

### 单 Agent 的认知偏差问题

单个 AI Agent 在完成复杂工程任务时，系统性地受到以下认知偏差的影响：

| 偏差 | 英文名 | 在 AI 工程中的表现 | 实际危害 |
|------|--------|-------------------|---------|
| 锚定效应 | Anchoring | 找到第一个可行方案后停止探索 | 错过更优架构 |
| 确认偏误 | Confirmation Bias | 寻找支持自己结论的证据，忽视矛盾证据 | 调试时锁定错误假设 |
| 视角盲点 | Perspective Blindness | 无法同时扮演用户、安全专家、性能工程师 | 关键视角缺失 |
| 自审失效 | Self-Review Failure | 审查自己产出时，潜意识填补逻辑空隙 | "看不到"自己的 bug |

---

#### 锚定效应 (Anchoring)

**定义**：第一个找到的解决方案成为思维锚点，后续所有思考都围绕这个锚点展开，而不是从头评估替代方案。

**在架构设计中的表现**：

```
单 Agent 思考过程：
┌─────────────────────────────────────────────┐
│ 1. 阅读 PRD                                │
│ 2. "这个可以用 REST API 实现" ← 锚定发生    │
│ 3. 设计 REST API 方案（精心打磨）            │
│ 4. "还有其他方案吗？嗯，GraphQL... 但       │
│     REST 已经够用了" ← 锚定导致浅层比较      │
│ 5. 产出：REST API 方案                      │
└─────────────────────────────────────────────┘
```

问题不在于 REST 一定是错的，而在于 GraphQL 从未获得"公平审判"。Agent 对第一个方案投入了大量思考，对替代方案只是走过场。

**对抗方案**：两个 Architect 独立设计，各自不知道对方的方案 → 两个方案都经过深入思考 → Arbiter 基于实际方案比较，而非一个精细方案 vs 一个草案。

---

#### 确认偏误 (Confirmation Bias)

**定义**：Agent 倾向于寻找支持其已有结论的证据，忽视或低估矛盾证据。

**在调试中的表现**：

```
单 Agent 调试过程：
┌─────────────────────────────────────────────┐
│ 1. 观察症状：API 响应慢                      │
│ 2. 假设："可能是数据库查询慢" ← 形成假设     │
│ 3. 查看慢查询日志 → 确实有慢查询 ← 确认!     │
│ 4. 优化查询                                 │
│ 5. 问题未解决...                             │
│ 6. 根本原因：网络层 DNS 解析超时              │
│    (Agent 从未检查网络层，因为已"找到原因")   │
└─────────────────────────────────────────────┘
```

**对抗方案**：Investigator 提出假设，Challenger 主动寻找反例 → 假设必须经受反面证据的考验才能被接受。

---

#### 视角盲点 (Perspective Blindness)

**定义**：单个 Agent 无法同时以用户倡导者、安全专家、性能工程师、可维护性审查者的视角评估同一个方案。这些角色需要根本不同的评估标准。

**评估标准冲突示例**：

| 视角 | 对"加缓存"的评估 |
|------|-----------------|
| 用户倡导者 | "太好了，响应更快！" |
| 安全专家 | "缓存可能泄露敏感数据" |
| 性能工程师 | "缓存失效策略是什么？" |
| 可维护性审查者 | "又增加一层要维护的复杂度" |

单 Agent 能意识到这些视角的存在，但无法同时深入地从每个视角思考。它会在视角之间快速切换，导致每个视角都只是浅层考虑。

**对抗方案**：不同 Agent 被分配不同角色，每个 Agent 深入扮演一个视角 → 每个视角都获得充分的思考深度。

---

#### 自审失效 (Self-Review Failure)

**定义**：同一个 Agent 审查自己的工作时，因为知道"创作过程"，会不自觉地填补逻辑空隙、忽略表述模糊。

**类比**：就像校对自己的文章 vs 让别人校对。你写作时心里知道自己要表达什么，所以即使写得不清楚，你也觉得"很清楚"。换一个从未见过这篇文章的人来读，问题立刻暴露。

**在代码审查中的表现**：

```
同一 Agent 写代码 + 审查：
- "这个函数名不够清晰" → 但我知道它做什么，所以觉得还行
- "错误处理不完整" → 但我知道调用者会处理，所以不担心
- "这个边界条件..." → 我测试时没遇到问题，应该没事

独立 Agent 审查：
- "这个函数名是什么意思？" → 必须改
- "调用者真的会处理这个错误吗？让我查..." → 发现调用者没处理
- "输入为空时会怎样？" → 发现 NPE
```

**对抗方案**：Creator 和 Reviewer 是不同 Agent → Reviewer 没有看过"创作过程"，只看成品 → 更客观的评估。

---

### 研究基础

这些认知偏差来自成熟的行为科学研究：

| 来源 | 核心观点 | forge-teams 应用 |
|------|---------|-----------------|
| Kahneman《思考，快与慢》 | 系统1（快速直觉）容易产生锚定和确认偏误 | 对抗辩论迫使"慢思考" |
| Red Teaming（情报分析） | 独立的反对方能发现盲点 | Skeptic/Critic 角色 |
| Devil's Advocacy（决策理论） | 指定反对者提高决策质量 | 结构化辩论协议 |
| 安全审计（Red Team / Blue Team） | 攻防分离比自审有效 | 角色分离原则 |

---

## 💡 对抗 vs 协作：何时用哪种 (Adversarial vs Collaborative)

并非所有阶段都需要对抗辩论。forge-teams 根据任务特性选择最合适的协作模式。

### 三种协作模式

```
┌────────────────────────────────────────────────────────┐
│                    协作模式光谱                          │
│                                                        │
│  对抗辩论          协作+审查          并行协作           │
│  ◄──────────────────────────────────────────────────►  │
│  适合主观判断       适合验证型任务      适合可分解任务     │
│  P1 P2 P5 P6      P3 P7             P4               │
└────────────────────────────────────────────────────────┘
```

### 模式选择矩阵

| 模式 | 适用场景 | 核心特征 | forge-teams 中的阶段 |
|------|---------|---------|-------------------|
| **对抗辩论** | 存在多个合理选择，需要选最优 | 角色对立，结构化辩论 | P1 需求、P2 设计、P5 审查、P6 调试 |
| **并行协作** | 任务可分解，结果需要合并 | 独立执行，统一整合 | P4 实现 |
| **协作+审查** | 一方产出，另一方验证 | 分工明确，验证环节 | P3 规划、P7 部署 |

### 为什么这样分配

**P1 需求 — 对抗辩论**：需求分析中最大的风险是"过于乐观"。Advocate 天然倾向于扩大范围和低估复杂度，Skeptic 用代码库事实制衡。

**P2 设计 — 对抗辩论**：架构决策是高杠杆决策（后期修改成本极高），值得投入多个 Agent 竞争和评审。

**P3 规划 — 协作+审查**：任务分解相对客观（代码要么需要改要么不需要），辩论价值有限。一方规划、另一方验证更高效。

**P4 实现 — 并行协作**：代码要么能跑要么不能跑，辩论不如实际写代码 + 跑测试。多 Agent 并行实现不同模块，测试是最终裁判。

**P5 审查 — 对抗辩论**：代码质量评估有主观成分（可读性、设计模式选择），对抗审查比自审有效。

**P6 调试 — 对抗辩论**：诊断阶段最容易产生确认偏误（锁定错误假设），对抗假设挑战是标准做法。

**P7 部署 — 协作+审查**：部署流程相对标准化，一方执行、另一方验证（检查清单式）更合适。

---

## 🔧 Agent Teams vs Subagents 核心区别

forge-teams 使用 Claude Code 的 Agent Teams 机制，而非 pdforge 使用的 Subagent 机制。这是根本性的架构差异。

### 通信模型对比

```
Subagent 模型 (pdforge):                Agent Teams 模型 (forge-teams):
┌──────────┐                            ┌──────────┐
│  主 Agent │                            │   Lead   │
└────┬─────┘                            └──┬───┬───┘
     │ 调用                                │   │ SendMessage
     ▼                                    ▼   ▼
┌──────────┐                       ┌──────┐   ┌──────┐
│ Subagent │ → 返回结果             │ Agent│◄─►│Agent │
└──────────┘                       │  A   │   │  B   │
     ↑                             └──────┘   └──────┘
     │ 无法通信                       SendMessage（双向）
     ↓
┌──────────┐
│ Subagent │ → 返回结果
└──────────┘
```

### 详细对比

| 维度 | Subagent (pdforge) | Agent Teams (forge-teams) |
|------|-------------------|--------------------------|
| **通信模型** | 单向：主 → 子 → 主 | 多向：agent <-> agent (via SendMessage) |
| **上下文** | 每个 subagent 全新隔离 | 每个 teammate 全新隔离 + 可通信 |
| **协调** | 主 agent 顺序调度 | Lead + TaskList + 自主 claim |
| **并行能力** | 无（顺序执行） | 有（多 agent 同时工作） |
| **适合场景** | 独立任务（审查、生成） | 需要协作/竞争的任务（辩论、并行） |
| **开销** | 低-中 | 高（多 agent sessions） |
| **团队协调 API** | 无 | TeamCreate, TaskCreate, SendMessage, TaskList |

### 为什么 forge-teams 需要 Agent Teams

**原因 1 — 辩论需要双向通信**：

```
对抗辩论流程：
Advocate → Skeptic: "这是我的 PRD"
Skeptic → Advocate: "第3条不可行，原因是..."
Advocate → Skeptic: "我修改了方案，解决了你的担忧"
Skeptic → Lead: "修改后可接受"

Subagent 模型无法实现：子 agent 之间无法通信
```

**原因 2 — 竞标需要并行独立工作**：

```
架构竞标流程：
Architect A: 独立设计方案 A（不看方案 B）
Architect B: 独立设计方案 B（不看方案 A）
    ↓ 同时进行
Critic: 同时评审两个方案
Arbiter: 比较评分

Subagent 模型无法实现：subagent 顺序执行，第二个 agent 可能看到第一个的结果
```

**原因 3 — 自主 claim 任务**：

```
并行实现流程：
TaskList: [Task 1, Task 2, Task 3, Task 4]
Agent A: claim Task 1 → 实现 → 完成 → claim Task 3
Agent B: claim Task 2 → 实现 → 完成 → claim Task 4

Subagent 模型无法实现：主 agent 必须手动分配每个任务
```

### 何时仍然用 Subagent

forge-teams 内部的某些子步骤仍可使用 subagent：
- 如果某个步骤是纯粹的独立生成任务（不需要与其他 agent 通信）
- 如果成本敏感且不需要对抗（简单的文档格式化等）

---

## ⚙️ 辩论收敛设计 (Debate Convergence Design)

### 为什么限制辩论轮数？

无限制的辩论会出现以下问题：

```
辩论价值曲线：
价值 ▲
     │    ┌────────────────── ~90% 价值
     │   /│
     │  / │
     │ /  │  ← 边际收益递减
     │/   │
     ├────┼──────────────────► 轮次
     1    2    3    4    5
```

### 不同阶段的辩论轮数

| 阶段 | 最大轮数 | 原因 |
|------|---------|------|
| P1 需求 | 2 | 挑战主要基于事实（代码库状态），结论明确 |
| P2 设计 | 3 | 架构权衡更复杂，需要更多轮次探索 |
| P5 审查 | 2 | 代码缺陷有明确判断标准 |
| P6 调试 | 3 | 假设排除是迭代过程，需要更多轮次 |

### 轮次内容设计

**3 轮辩论的标准结构（P2 设计为例）**：

| 轮次 | 目的 | 深度 |
|------|------|------|
| Round 1 | 初始立场陈述，附带证据 | 广度覆盖 |
| Round 2 | 针对对方论点的反驳和回应 | 深度反驳 |
| Round 3 | 最终精炼，聚焦未解决分歧 | 聚焦收敛 |

**研究依据**：结构化分析技术（Structured Analytical Techniques, SAT）文献表明，3 轮结构化辩论可捕获约 90% 的洞察价值。第 4 轮及以后更多产生噪音而非信号——参与者开始重复论点或纠缠细枝末节。

### 提前终止条件

辩论可在达到最大轮数前终止：
- **共识达成**：双方在关键分歧点达成一致
- **事实裁决**：通过代码库证据明确判定一方正确
- **FATAL 否决**：方案存在无法修复的致命缺陷，直接淘汰

---

## 🚀 角色分离原则 (Role Separation Principle)

### 核心原则：Investigator ≠ Challenger ≠ Judge

```
三角色模式（在 P1, P2, P5, P6 中重复出现）：

         ┌───────────┐
         │   Judge   │  ← 做出最终判定
         │ (Arbiter) │
         └─────┬─────┘
               │ 裁决
         ┌─────┴─────┐
         │           │
    ┌────▼────┐ ┌────▼─────┐
    │Creator  │ │Challenger│  ← 对立角色
    │(产出方) │ │(挑战方)  │
    └─────────┘ └──────────┘
```

### 为什么不能合并角色

**Creator + Challenger 合并 → 自审失效**：

同一 Agent 既创造又挑战，最终会对自己的作品手下留情。它知道自己的设计意图，所以会不自觉地为缺陷找借口："这个边界情况在实际使用中很少见"。

**Challenger + Judge 合并 → 角色冲突**：

挑战者的目标是尽可能找到问题（对抗性），裁判的目标是公平评估（中立性）。合并后，Agent 可能：
- 在挑战阶段就"预判"结果，导致挑战不彻底
- 或者在裁判阶段受挑战时的情绪影响，偏向否定

**Creator + Judge 合并 → 利益冲突**：

创造者评判自己的作品，天然偏向于给高分。

### 各阶段的角色映射

| 阶段 | Creator | Challenger | Judge |
|------|---------|-----------|-------|
| P1 需求 | product-advocate | technical-skeptic | Lead (主 session) |
| P2 设计 | solution-architect (×2) | technical-critic | design-arbiter |
| P5 审查 | 原 implementer (代码已存在) | code-critic + security-reviewer | Lead (主 session) |
| P6 调试 | hypothesis-generator | evidence-challenger | Lead (主 session) |

### Lead 的特殊角色

在 P1 和 P5 中，Lead（主 session）兼任 Judge 角色。这是一个有意的简化：

| 选择 | 优点 | 缺点 |
|------|------|------|
| 独立 Arbiter | 更客观 | +1 agent session，成本更高 |
| Lead 兼任 | 少 1 agent，Lead 有完整上下文 | Lead 可能偏向某一方 |

**决策**：P1 和 P5 使用 Lead 兼任，因为这些阶段的辩论较短（2 轮），Lead 的偏向风险可控。P2 使用独立 Arbiter，因为架构决策更复杂，需要完全中立的裁判。

---

## ⚠️ 反模式 (Anti-Patterns)

### 设计层面

| 反模式 | 症状 | 正确做法 |
|--------|------|---------|
| 伪对抗 | 所有 Agent 使用相同 prompt，只是名字不同 | 每个角色有根本不同的评估标准和目标 |
| 无限辩论 | 没有轮数限制，Agent 陷入循环 | 严格限制轮数 + 提前终止条件 |
| 角色泄漏 | Creator 在 prompt 中被告知 Challenger 的策略 | 角色信息严格隔离 |
| 过度对抗 | 所有阶段都用对抗模式 | 根据任务特性选择协作模式 |
| 成本盲目 | 不考虑 token 成本，所有地方都用 opus | 高杠杆决策用 opus，生产任务用 sonnet |

### 使用层面

| 反模式 | 症状 | 正确做法 |
|--------|------|---------|
| 跳过阶段 | 直接从需求跳到实现 | 每个阶段的输出是下一阶段的输入 |
| 忽视否决 | 有 FATAL 挑战的方案继续推进 | FATAL = 硬否决，必须解决或放弃方案 |
| 手动干预辩论 | 用户在辩论中途修改 Agent 立场 | 让辩论自然完成，在综合阶段提供输入 |
| 单阶段使用 | 只用 P2 不用 P1 | 各阶段有依赖关系，建议完整流程 |

---

## 🔗 延伸阅读

| 主题 | 资源 |
|------|------|
| 阶段 1：对抗需求分析 | `docs/phase-1-adversarial-requirements.md` |
| 阶段 2：对抗架构设计 | `docs/phase-2-adversarial-design.md` |
| 对抗辩论规则 | `rules/adversarial-protocol.md` |
| pdforge 对比 | 各阶段文档的 "vs pdforge 对比" 章节 |
