# 阶段 2：对抗架构设计 (Adversarial Design)

> 通过架构竞标 + 多维技术评审，选出经过压力测试的最优架构方案

---

## 📋 阶段概述

| 维度 | 说明 |
|------|------|
| **目标** | 通过架构竞标 + 技术评审，选出最优架构方案 |
| **输入** | Battle-tested PRD（来自阶段1） |
| **输出** | ADR 文档、架构设计、被否决方案记录 |
| **上游阶段** | 对抗需求分析（阶段1） |
| **下游阶段** | 协作规划（阶段3） |

---

## 🧩 组件清单

| 类型 | 名称 | 说明 |
|------|------|------|
| **Agent** | `solution-architect` | 方案架构师，提出设计方案（可多实例, sonnet） |
| **Agent** | `technical-critic` | 技术评论家，从 6 维度挑战（opus） |
| **Agent** | `design-arbiter` | 设计仲裁者，评分裁决（opus） |
| **Skill** | `adversarial-design` | Phase 2 编排: 5 阶段协议 |
| **Rule** | `adversarial-protocol.md` | 10 条对抗辩论规则 |

---

## 💡 为什么这样设计

### 单架构师的问题

单个架构师（无论人类还是 AI）产出一个设计方案后进入"精炼循环"：

```
单架构师设计过程（锚定效应典型表现）：
┌──────────────────────────────────────────────────────┐
│ 1. 阅读 PRD                                         │
│ 2. 初始直觉："微服务架构比较合适" ← 锚定发生          │
│ 3. 深入设计微服务方案（投入大量思考）                  │
│ 4. "要不要考虑单体？"                                │
│    → "微服务方案已经很成熟了" ← 沉没成本效应           │
│ 5. 自我审查："有什么问题吗？"                          │
│    → "看起来很完善" ← 自审失效                        │
│ 6. 产出：微服务方案（未经对比验证）                    │
└──────────────────────────────────────────────────────┘
```

核心问题：

| 问题 | 原因 | 后果 |
|------|------|------|
| 无对比基线 | 只有一个方案，无法判断"好不好" | 可能选了局部最优 |
| 锚定效应 | 第一个方案获得不成比例的注意力 | 替代方案被浅层否定 |
| 自审失效 | 架构师审查自己的设计 | 盲点无法暴露 |
| 信息损失 | 只记录最终方案，不记录被否定的替代 | 后续无法理解决策原因 |

---

### 为什么竞标模式（Bakeoff）

forge-teams P2 采用**架构竞标**而非单一设计：

```
竞标模式：
┌────────────────┐     ┌────────────────┐
│  Architect A   │     │  Architect B   │
│                │     │                │
│ 阅读 PRD       │     │ 阅读 PRD       │
│ 阅读代码库     │     │ 阅读代码库      │
│ 独立设计       │     │ 独立设计        │  ← 彼此不可见
│ 方案 A         │     │ 方案 B          │
└───────┬────────┘     └───────┬────────┘
        │                      │
        └──────────┬───────────┘
                   ▼
          ┌────────────────┐
          │ Technical      │
          │ Critic         │  ← 同时评审两个方案
          │ (6 维度攻击)    │
          └───────┬────────┘
                  ▼
          ┌────────────────┐
          │ Design         │
          │ Arbiter        │  ← 评分矩阵裁决
          │ (加权评分)      │
          └───────┬────────┘
                  ▼
          ┌────────────────┐
          │ 最终方案        │  ← 可能合并两个方案的优点
          │ + ADR          │
          │ + 被否决记录    │
          └────────────────┘
```

竞标模式的核心优势：

| 优势 | 机制 | 对比单架构师 |
|------|------|------------|
| **消除锚定** | 两个架构师独立思考，互不可见 | 单架构师被第一个想法锚定 |
| **自然对比** | Arbiter 比较两个真实方案 | 单架构师比较精细方案 vs 草案 |
| **最优解浮现** | 最终方案可合并两个方案的最佳部分 | 单方案无合并可能 |
| **决策透明** | ADR 记录为什么选 A 不选 B | ADR 的"替代方案"往往敷衍 |

**灵感来源**：

- Architecture Decision Records (ADR)：记录替代方案是 ADR 的核心要求
- Google Design Review Process：多个工程师独立审查设计文档
- 军事 Red Team / Blue Team：攻防演练发现系统弱点
- 建筑竞标 (Architecture Competition)：多个建筑师提交方案，评审选最优

---

### 为什么 Critic 和 Arbiter 分离

```
角色对比：
┌──────────────────────┐    ┌──────────────────────┐
│   Technical Critic   │    │   Design Arbiter     │
│                      │    │                      │
│ 目标：尽可能找问题    │    │ 目标：公平评估        │
│ 心态：对抗性          │    │ 心态：中立性          │
│ 输出：挑战 + 严重级别 │    │ 输出：评分矩阵 + 裁决 │
│                      │    │                      │
│ "这个设计在高并发下   │    │ "方案 A 的可扩展性    │
│  会崩溃，因为..."     │    │  得分 4/5，方案 B 得   │
│                      │    │  分 3/5，原因是..."    │
└──────────────────────┘    └──────────────────────┘
```

**为什么不合并 Critic + Arbiter？**

| 合并后的问题 | 具体表现 |
|-------------|---------|
| 预判偏差 | 挑战阶段就"知道"自己会做裁判，可能提前形成倾向 |
| 攻击深度不足 | 知道自己之后要公平评估，可能"手下留情" |
| 角色冲突 | 同时需要"尽可能找问题"和"公平权衡"是矛盾目标 |
| 裁判污染 | 挑战过程中积累的情绪影响后续裁判 |

类比：**法庭中检察官 (Critic) 和法官 (Arbiter) 必须是不同的人**。检察官的工作是尽力指控，法官的工作是公正裁判。如果同一个人做两件事，司法公正无法保障。

---

### 为什么 Architect 用 sonnet，Critic/Arbiter 用 opus

模型选择基于任务特性：

| 角色 | 任务类型 | 关键能力需求 | 模型 | 原因 |
|------|---------|------------|------|------|
| Architect | 创造性生产 | 代码理解 + 方案生成 | sonnet | 设计方案是"生成"任务，sonnet 足够 |
| Critic | 深度分析 | 多维度推理 + 缺陷发现 | opus | 需要发现非显而易见的问题 |
| Arbiter | 复杂判断 | 多方案权衡 + 校准评分 | opus | 需要精确的比较和判断能力 |

**成本权衡**：

```
Token 成本分布（近似）：
┌────────────────────────────────────────────┐
│ Architect A (sonnet):  ████████  ~20%      │
│ Architect B (sonnet):  ████████  ~20%      │
│ Critic (opus):         ████████████  ~30%  │
│ Arbiter (opus):        ████████████  ~30%  │
│                                            │
│ 总计 ≈ pdforge architect 的 8x             │
└────────────────────────────────────────────┘
```

为什么不全用 sonnet？Critic 用 sonnet 可能遗漏深层架构问题。在架构决策这种"高杠杆"场景下（错误决策的修复成本极高），opus 的推理优势值得投资。

为什么不全用 opus？Architect 的设计工作是"生产性"的，sonnet 在生成任务上的质量足够，且成本低一半。

---

### 为什么最多 3 轮

| 轮次 | 目的 | 典型内容 |
|------|------|---------|
| Round 1 | 初始评审 | Critic 识别两个方案的方向性问题 |
| Round 2 | 深入辩论 | Architect 回应挑战，Critic 追问 |
| Round 3 | 最终精炼（可选） | 仅在评分接近时触发 |

**Round 3 触发条件**：

```
if abs(score_A - score_B) < 0.5:
    trigger_round_3()  # 分数太接近，需要更多信息
else:
    skip_round_3()      # 高下已分
```

大多数情况下 2 轮就够——两个方案的优劣在 Round 2 结束时通常已经明确。Round 3 是为了处理"势均力敌"的少数情况。

---

### 关键设计决策

| 决策 | 选项 | 选择 | 原因 |
|------|------|------|------|
| 架构师数量 | 2 vs 3+ | 2 | 2 个方案提供充分对比，3+ 收敛难度大增 |
| Critic 数量 | 1 vs 2 | 1 | 一个 opus critic 的分析深度足够 |
| Arbiter 数量 | 1 vs 3 (投票) | 1 | 3 个 opus arbiter 成本过高，1 个配评分矩阵足够 |
| 评分维度 | 3 vs 6 vs 10 | 6 | 覆盖核心关切，不过度细分导致区分度下降 |
| 评分权重 | 等权 vs 加权 | 加权 | 不同维度重要性不同，加权更准确 |
| 方案合并 | 允许 vs 不允许 | 允许 | 最终方案可取两家之长 |
| 独立设计 | 严格隔离 vs 允许参考 | 严格隔离 | 防止锚定效应 |

---

## 🔧 组件详解

### 1. solution-architect Agent (x2 instances)

```yaml
---
name: solution-architect
model: sonnet
tools: Read, Grep, Glob, Bash
---
```

**职责**：独立阅读 PRD 和代码库，产出完整的架构设计方案。

**方案交付物**：

| 交付物 | 内容 | 格式 |
|--------|------|------|
| 数据模型 | 实体关系、数据流 | ER 图 (Mermaid) |
| API 设计 | 端点、请求/响应格式 | OpenAPI 风格描述 |
| 组件架构 | 系统分层、模块划分 | C4 Model (Context/Container) |
| 安全架构 | 认证、授权、数据保护 | 安全控制矩阵 |
| 迁移策略 | 从当前状态到目标状态的路径 | 步骤列表 + 风险标注 |

**独立设计约束**：

```
⚠️ 严格隔离规则（Phase A）
┌──────────────────────────────────────────────┐
│ Architect A 和 Architect B 在提交方案前       │
│ 不得通过 SendMessage 交流。                    │
│                                              │
│ 违反此规则会导致锚定效应，                      │
│ 使竞标失去意义。                               │
│                                              │
│ Lead 在 Phase A 结束前不向任何一方               │
│ 透露另一方的方案方向。                          │
└──────────────────────────────────────────────┘
```

**回应挑战规范**：

收到 Critic 挑战后，Architect 必须：
1. 逐条回应每个挑战
2. 提供代码级别的证据（不能只说"可以解决"）
3. 如果挑战有效，修改方案并说明变更
4. 如果挑战无效，用代码证据反驳

---

### 2. technical-critic Agent

```yaml
---
name: technical-critic
model: opus
tools: Read, Grep, Glob, Bash
---
```

**职责**：从 6 个维度同时评审两个架构方案，识别弱点和风险。

**6 维度挑战框架**：

| # | 维度 | 英文 | 关注焦点 | 权重参考 |
|---|------|------|---------|---------|
| 1 | 可扩展性 | Scalability | 负载增长时的瓶颈 | 20% |
| 2 | 单点故障 | Single Point of Failure | 故障传播和恢复能力 | 15% |
| 3 | 实现成本 | Implementation Cost | 开发工作量和复杂度 | 15% |
| 4 | 系统复杂度 | System Complexity | 认知负担和维护成本 | 20% |
| 5 | 技术风险 | Technical Risk | 依赖不成熟技术或复杂集成 | 15% |
| 6 | 迁移路径 | Migration Path | 从当前状态到目标状态的可行性 | 15% |

**挑战严重级别**：

| 级别 | 英文 | 含义 | 处理方式 |
|------|------|------|---------|
| 致命 | FATAL | 方案根本不可行或有不可修复的缺陷 | 方案自动淘汰（否决权） |
| 严重 | CRITICAL | 重大风险，需要根本性修改 | 必须在回应中解决 |
| 重要 | SIGNIFICANT | 值得注意的问题，需要调整 | 应该在回应中处理 |
| 建议 | ADVISORY | 可改进之处，不影响方案可行性 | 可选择性处理 |

**挑战格式**：

```markdown
### CHALLENGE-P2-001: [维度] [标题]
**严重级别**: FATAL / CRITICAL / SIGNIFICANT / ADVISORY
**目标方案**: 方案 A / 方案 B / 两者
**问题描述**: [具体技术问题]
**代码证据**: `src/core/database.ts:145-178`
**攻击向量/失败场景**: [如何触发此问题]
**影响范围**: [此问题波及的系统部分]
```

**挑战强度递增规则**：

| 轮次 | 挑战策略 | 关注层次 |
|------|---------|---------|
| Round 1 | 方向性挑战 | 架构层面：整体结构是否合理 |
| Round 2 | 深度挑战 | 实现层面：具体细节是否可行 |
| Round 3 | 极端场景 | 边界层面：极端条件下是否崩溃 |

---

### 3. design-arbiter Agent

```yaml
---
name: design-arbiter
model: opus
tools: Read, Grep, Glob, Bash
---
```

**职责**：基于 Critic 的评审结果和 Architect 的回应，通过评分矩阵做出最终裁决。

**6 维度加权评分矩阵**：

```
┌───────────────────────────────────────────────────────────┐
│                    评分矩阵 (Scoring Matrix)               │
├──────────────┬──────┬───────────┬───────────┬────────────┤
│ 维度         │ 权重 │ 方案 A    │ 方案 B    │ 评分标准    │
├──────────────┼──────┼───────────┼───────────┼────────────┤
│ 可行性       │ 25%  │ ?/5       │ ?/5       │ 代码库适配  │
│ 可扩展性     │ 20%  │ ?/5       │ ?/5       │ 10x 负载    │
│ 可维护性     │ 20%  │ ?/5       │ ?/5       │ 认知复杂度  │
│ 安全性       │ 15%  │ ?/5       │ ?/5       │ 攻击面      │
│ 实现成本     │ 10%  │ ?/5       │ ?/5       │ 工作量估计  │
│ 团队适配     │ 10%  │ ?/5       │ ?/5       │ 学习曲线    │
├──────────────┼──────┼───────────┼───────────┼────────────┤
│ 加权总分     │ 100% │ ?.??/5    │ ?.??/5    │            │
└──────────────┴──────┴───────────┴───────────┴────────────┘
```

**致命缺陷否决权**：

```
裁决流程：
┌────────────────────────────────────┐
│ 1. 检查 FATAL 挑战                 │
│    ├─ 方案有未解决 FATAL → 自动淘汰 │
│    └─ 无 FATAL → 继续评分          │
│                                    │
│ 2. 6 维度评分                       │
│    └─ 每个维度 1-5 分              │
│                                    │
│ 3. 加权总分                        │
│    └─ 选择高分方案                  │
│                                    │
│ 4. 合并机会识别                     │
│    └─ 从落选方案中提取优点          │
│                                    │
│ 5. 最终裁决                        │
│    ├─ 选择方案 + 合并建议           │
│    └─ 被否决方案记录               │
└────────────────────────────────────┘
```

**合并机会识别**：

Arbiter 的一个关键能力是从落选方案中识别值得保留的元素：

```markdown
## 合并建议
| 来源 | 元素 | 合并方式 |
|------|------|---------|
| 方案 B (落选) | 缓存策略 | 替换方案 A 的缓存层 |
| 方案 B (落选) | 错误处理模式 | 补充方案 A 的错误处理 |
```

---

### 4. adversarial-design Skill

**5 阶段编排协议**：

```
┌─────────────────────────────────────────────────────────┐
│                adversarial-design 5 阶段协议              │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Phase A: 独立设计 (Independent Design)                  │
│  ├─ Architect A: 阅读 PRD + 代码库 → 设计方案 A          │
│  └─ Architect B: 阅读 PRD + 代码库 → 设计方案 B          │
│      ⚠️ A 和 B 不可交流                                  │
│                                                         │
│  Phase B: 技术评审 (Technical Review)                    │
│  └─ Critic: 同时评审方案 A 和 B → 6 维度挑战列表         │
│                                                         │
│  Phase C: 辩论 (Debate, 2-3 rounds)                     │
│  ├─ Round 1: Architect 回应 Critic 挑战                  │
│  ├─ Round 2: Critic 追问 + Architect 最终回应            │
│  └─ Round 3: (可选) 仅在评分接近时触发                    │
│                                                         │
│  Phase D: 裁决 (Adjudication)                            │
│  └─ Arbiter: 评分矩阵 → 选择方案 → 合并建议              │
│                                                         │
│  Phase E: 产出 (Output)                                  │
│  └─ Lead: 生成 ADR + 架构文档 + 被否决方案记录             │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

**Phase 详解**：

| Phase | 执行者 | 持续时间 | 输入 | 输出 |
|-------|--------|---------|------|------|
| A. 独立设计 | Architect A, B (并行) | 最长 | PRD + 代码库 | 2 个完整方案 |
| B. 技术评审 | Critic | 中等 | 2 个方案 | 挑战列表 |
| C. 辩论 | All architects + Critic | 中等 | 挑战列表 | 回应 + 修改方案 |
| D. 裁决 | Arbiter | 较短 | 方案 + 挑战 + 回应 | 评分 + 裁决 |
| E. 产出 | Lead | 较短 | 裁决结果 | ADR + 文档 |

---

## 🚀 使用流程

### 完整流水线中自动执行

```bash
# forge-teams 从阶段1完成后自动进入阶段2
/forge-teams "支付系统重构"
```

### 单独执行阶段2（需已有 PRD）

```bash
# 需要已存在 Battle-tested PRD
/forge-teams --phase 2
```

### 输出文件

| 文件 | 路径 | 说明 |
|------|------|------|
| 架构设计 | `docs/architecture/[feature]-design.md` | 胜选方案的完整架构 |
| ADR | `docs/adr/[number]-[title].md` | 架构决策记录（含替代方案） |
| 被否决记录 | `docs/architecture/[feature]-rejected.md` | 落选方案及原因 |
| 评分矩阵 | 包含在 ADR 中 | 6 维度评分详情 |

### 输出示例

**ADR 示例**：

```markdown
# ADR-003: 支付系统架构选择

## 状态
接受

## 上下文
需要重构支付系统以支持多币种和新支付网关。
两个竞争方案经过 3 轮对抗评审。

## 决策
选择方案 A（事件驱动架构），并合并方案 B 的缓存策略。

## 评分矩阵
| 维度 | 权重 | 方案 A | 方案 B | 说明 |
|------|------|--------|--------|------|
| 可行性 | 25% | 4/5 | 3/5 | A 更适配现有代码库 |
| 可扩展性 | 20% | 5/5 | 4/5 | 事件驱动天然可扩展 |
| 可维护性 | 20% | 3/5 | 4/5 | B 的模块化更清晰 |
| 安全性 | 15% | 4/5 | 4/5 | 持平 |
| 实现成本 | 10% | 3/5 | 4/5 | B 实现更简单 |
| 团队适配 | 10% | 4/5 | 3/5 | 团队更熟悉事件驱动 |
| **加权总分** | 100% | **3.90** | **3.65** | |

## 合并建议
从方案 B 中提取缓存策略（Redis + TTL），替换方案 A 原始的内存缓存。

## 被否决方案摘要
方案 B（微服务架构）：整体得分 3.65/5。
- 优点：模块化清晰、实现成本低
- 否决原因：可扩展性不如事件驱动、与现有代码库适配度较低
- 保留元素：缓存策略已合并到最终方案

## 后果
- 正面：可扩展性好，与现有架构兼容
- 负面：事件驱动增加调试难度（需投资可观测性）
```

---

## 📊 工作流图

```
┌───────────────────────────────────────────────────────────────┐
│                  Phase 2: Adversarial Design                  │
├───────────────────────────────────────────────────────────────┤
│                                                               │
│  输入                                                         │
│  ┌───────────────────┐                                       │
│  │ Battle-tested PRD │ (来自 P1)                              │
│  └─────────┬─────────┘                                       │
│            │                                                  │
│  Phase A ──┼───────────────────────────────────               │
│            │                                                  │
│     ┌──────▼──────┐           ┌─────────────┐                │
│     │ Architect A │           │ Architect B │  独立设计       │
│     │  (sonnet)   │           │  (sonnet)   │  互不可见       │
│     └──────┬──────┘           └──────┬──────┘                │
│            │ 方案 A                   │ 方案 B                │
│  Phase B ──┼─────────────────────────┼────────               │
│            └──────────┬──────────────┘                        │
│                       ▼                                       │
│              ┌────────────────┐                               │
│              │ Technical      │  6 维度挑战                    │
│              │ Critic (opus)  │                               │
│              └───────┬────────┘                               │
│  Phase C ────────────┼──────────────────────                  │
│                      │ 挑战列表                                │
│              ┌───────▼────────┐                               │
│              │   2-3 轮辩论   │  Architect ↔ Critic           │
│              └───────┬────────┘                               │
│  Phase D ────────────┼──────────────────────                  │
│                      ▼                                        │
│              ┌────────────────┐                               │
│              │ Design Arbiter │  评分矩阵 + 裁决               │
│              │   (opus)       │                               │
│              └───────┬────────┘                               │
│  Phase E ────────────┼──────────────────────                  │
│                      ▼                                        │
│    ┌─────────────────────────────────────────────────────┐   │
│    │ ADR + 架构设计 + 被否决方案记录                        │   │
│    │ docs/architecture/[feature]-design.md               │   │
│    │ docs/adr/[number]-[title].md                        │   │
│    │ docs/architecture/[feature]-rejected.md             │   │
│    └─────────────────────────────────────────────────────┘   │
│                                                               │
└───────────────────────────────────────────────────────────────┘
```

---

## ⚙️ vs pdforge 对比

| 维度 | pdforge (architect agent) | forge-teams (P2) | 价值 |
|------|--------------------------|------------------|------|
| **方案数量** | 1 个 | 2 个竞争 | 避免锚定在首个方案 |
| **评审** | 无独立评审 | critic 6 维度攻击 + arbiter 评分 | 更深入的设计审查 |
| **模型** | 单 opus | 2 sonnet + 2 opus | 生产用 sonnet，判断用 opus |
| **输出** | ADR | ADR + 被否决方案记录 + 合并建议 | 更完整的决策记录 |
| **替代方案** | ADR 中简略描述 | 完整的竞争方案文档 | 后续可回溯决策 |
| **Token 消耗** | 1x | ~8x | 架构决策的高杠杆性值得投资 |

### 何时用 pdforge，何时用 forge-teams P2

| 场景 | 推荐 | 原因 |
|------|------|------|
| 简单模块添加 | pdforge | 架构影响小，不值得竞标 |
| 核心架构决策 | forge-teams | 高杠杆决策，错误成本极高 |
| 有明确技术约束 | pdforge | 约束明确时方案空间小 |
| 多种方案可选 | forge-teams | 竞标发挥最大价值 |
| 时间紧迫 | pdforge | 速度优先 |
| 长期维护系统 | forge-teams | 投资架构质量回报高 |

---

## ⚠️ 注意事项

1. **独立设计**：两个 Architect 在 Phase A（独立设计阶段）不得交流。Lead 在 Phase A 期间不向任一 Architect 透露另一方的设计方向。这是防止锚定效应的核心机制。

2. **FATAL 否决**：有未解决的 FATAL 级别挑战的方案自动淘汰，无论其他维度得分多高。这是硬性规则，Arbiter 无权覆盖。

3. **被否决方案保留**：输出中必须保留被否决的方案及其原因。这些信息对后续维护和未来架构演进有重要参考价值。常见情况：当前被否的方案在系统规模扩大后可能变成更优选择。

4. **评分透明**：Arbiter 必须公开完整的评分矩阵和权重计算过程。不允许"黑箱裁决"。每个维度的评分必须附带具体理由。

5. **合并不是必须**：Arbiter 识别合并机会是"可选"而非"强制"。如果胜选方案已足够优秀，或两个方案差异太大无法合并，可以不合并。

6. **回退机制**：如果两个方案都有未解决的 FATAL 挑战（极端情况），流程回退到 P1 重新评估需求，因为可能是需求本身有问题。

7. **成本意识**：P2 约消耗 pdforge architect 的 8 倍 token。在决定使用 forge-teams P2 前，确认架构决策的重要性值得这个投资。

---

## 🔗 下一阶段

架构选定后，进入 **阶段 3：协作规划**。

```bash
# 完整流水线中自动流转
# 或手动触发：
/forge-teams --phase 3
```

阶段 3 将基于选定的架构方案进行任务分解和排期规划。
